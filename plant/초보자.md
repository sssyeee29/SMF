# Spring Boot 프로젝트 개발 가이드

## 목차
1. [프로젝트 초기 설정](#1-프로젝트-초기-설정)
2. [기본 구조 설정](#2-기본-구조-설정)
3. [데이터베이스 설정](#3-데이터베이스-설정)
4. [보안 설정](#4-보안-설정)
5. [공통 모듈 개발](#5-공통-모듈-개발)
6. [비즈니스 로직 개발](#6-비즈니스-로직-개발)
7. [배포 및 운영](#7-배포-및-운영)

---

## 1. 프로젝트 초기 설정

### 1.1 Spring Boot 프로젝트 생성

```bash
# Spring Initializr를 사용하여 프로젝트 생성
# https://start.spring.io/

# 선택한 의존성들:
- Spring Web
- Spring Security
- Spring Data JPA
- MyBatis Framework
- MySQL Driver
- Lombok
- Validation
```

### 1.2 기본 프로젝트 구조

```
plant/
├── build.gradle
├── settings.gradle
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── plant/
│   │   │       ├── plantApplication.java
│   │   │       └── com/
│   │   │           ├── cmm/          # 공통 모듈
│   │   │           ├── config/       # 설정
│   │   │           ├── jwt/          # JWT 인증
│   │   │           ├── security/     # 보안
│   │   │           └── dev/          # 비즈니스 로직
│   │   └── resources/
│   │       ├── application.properties
│   │       ├── messages/
│   │       └── plant/
│   └── test/
└── gradlew
```

---

## 2. 기본 구조 설정

### 2.1 패키지 구조 설계

**왜 이렇게 패키지를 나눴는가?**

1. **com.cmm (Common)**: 공통으로 사용되는 모듈들
   - DAO, Exception, Filter, Interceptor, Util 등
   - 재사용 가능한 컴포넌트들을 모아둠

2. **com.config**: 설정 관련 클래스들
   - 각종 Configuration 클래스들
   - 빈 설정, 보안 설정 등

3. **com.jwt**: JWT 인증 관련
   - 토큰 생성, 검증, 필터링
   - 비밀번호 인코더들

4. **com.security**: Spring Security 설정
   - 보안 정책, 필터 체인 설정

5. **dev**: 실제 비즈니스 로직
   - auth, menu 등 도메인별 패키지

### 2.2 build.gradle 설정

```gradle
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.2.0'
    id 'io.spring.dependency-management' version '1.1.4'
}

group = 'plant'
version = '0.0.1-SNAPSHOT'

java {
    sourceCompatibility = '17'
}

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
}

dependencies {
    // Spring Boot Starters
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    
    // MyBatis
    implementation 'org.mybatis.spring.boot:mybatis-spring-boot-starter:3.0.3'
    
    // Database
    implementation 'mysql:mysql-connector-java:8.0.33'
    
    // JWT
    implementation 'io.jsonwebtoken:jjwt-api:0.12.3'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.12.3'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.12.3'
    
    // Jasypt (암호화)
    implementation 'com.github.ulisesbocchio:jasypt-spring-boot-starter:3.0.5'
    
    // P6Spy (SQL 로깅)
    implementation 'com.github.gavlyukovskiy:p6spy-spring-boot-starter:1.9.0'
    
    // Lombok
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    
    // Test
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.security:spring-security-test'
}
```

---

## 3. 데이터베이스 설정

### 3.1 JPA와 MyBatis를 함께 사용하는 이유

**왜 JPA와 MyBatis를 동시에 사용하는가?**

1. **JPA의 장점**
   - 객체 지향적 데이터 접근
   - 자동 쿼리 생성
   - 엔티티 관리의 편의성
   - 복잡한 연관관계 처리

2. **MyBatis의 장점**
   - 복잡한 쿼리 작성의 유연성
   - SQL 직접 제어
   - 성능 최적화
   - 레거시 시스템과의 호환성

3. **하이브리드 접근법**
   - JPA: 엔티티 관리, 기본 CRUD
   - MyBatis: 복잡한 쿼리, 통계, 리포트

### 3.2 PersistenceConfig.java 설정

```java
@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(
    basePackages = "plant.dev.jpa.repository",
    entityManagerFactoryRef = "entityManagerFactory",
    transactionManagerRef = "transactionManager"
)
public class PersistenceConfig {
    
    // DataSource 설정
    @Bean
    @Profile("prod")
    public DataSource dataSource() {
        // 운영 환경용 설정
    }
    
    @Bean
    @Profile("!prod")
    public DataSource devDataSource() {
        // 개발 환경용 설정
    }
    
    // MyBatis 설정
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
        // MyBatis 설정
    }
    
    // JPA 설정
    @Bean
    public LocalContainerEntityManagerFactoryBean entityManagerFactory(DataSource dataSource) {
        // JPA 설정
    }
    
    // 트랜잭션 매니저 설정 (ChainedTransactionManager 사용)
    @Bean
    @Primary
    public PlatformTransactionManager transactionManager(
            @Qualifier("jpaTransactionManager") PlatformTransactionManager jpaTransactionManager,
            @Qualifier("mybatisTransactionManager") PlatformTransactionManager mybatisTransactionManager
    ) {
        return new ChainedTransactionManager(jpaTransactionManager, mybatisTransactionManager);
    }
}
```

### 3.3 ChainedTransactionManager 사용 이유

```java
// 여러 트랜잭션 매니저를 체인으로 연결
// JPA → MyBatis 순서로 트랜잭션 처리
// 하나라도 실패하면 전체 롤백
```

---

## 4. 보안 설정

### 4.1 JWT 인증 시스템

**왜 JWT를 사용하는가?**

1. **Stateless 인증**
   - 서버에 세션 저장 불필요
   - 확장성 좋음
   - 마이크로서비스에 적합

2. **구현된 JWT 구조**
   ```
   com.jwt/
   ├── JwtUtil.java                    # 토큰 생성/검증
   ├── JwtAuthenticationFilter.java     # 요청 필터링
   ├── JwtAuthenticationEntryPoint.java # 인증 실패 처리
   └── password/
       ├── BCryptPasswordEncoderComponent.java
       ├── JasyptPasswordEncoderComponent.java
       └── NonPasswordEncoderComponent.java
   ```

### 4.2 SecurityConfig.java 설정

```java
@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {
    
    private final JwtUtil jwtUtil;
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/auth/**").permitAll()
                .anyRequest().authenticated()
            )
            .addFilterBefore(new JwtAuthenticationFilter(jwtUtil), UsernamePasswordAuthenticationFilter.class)
            .exceptionHandling(exception -> exception
                .authenticationEntryPoint(new JwtAuthenticationEntryPoint())
            );
        
        return http.build();
    }
}
```

### 4.3 비밀번호 인코더 전략

**왜 여러 인코더를 만들었는가?**

1. **BCryptPasswordEncoderComponent**
   - 일반적인 비밀번호 암호화
   - Salt 자동 생성

2. **JasyptPasswordEncoderComponent**
   - 설정 파일 암호화와 동일한 방식
   - 일관성 유지

3. **NonPasswordEncoderComponent**
   - 개발/테스트 환경용
   - 암호화 없이 처리

---

## 5. 공통 모듈 개발

### 5.1 XSS 방지 시스템

**왜 XSS 방지를 이렇게 구현했는가?**

1. **Filter 기반 접근**
   ```
   com.cmm.filter/
   ├── EscapeFilter.java                    # 메인 필터
   ├── EscapeRequestWrapper.java            # JSON 요청 처리
   ├── EscapeParameterRequestWrapper.java   # 파라미터 처리
   └── EsxapeFilerPattern.java             # 패턴 필터링
   ```

2. **다양한 공격 패턴 대응**
   ```java
   // <script> 태그 제거
   // javascript: 스키마 차단
   // 이벤트 핸들러 차단
   // eval(), alert() 함수 차단
   ```

3. **JSON과 파라미터 분리 처리**
   - JSON: EscapeRequestWrapper
   - 파라미터: EscapeParameterRequestWrapper

### 5.2 예외 처리 시스템

```java
com.cmm.exception/
├── CustomException.java        # 비즈니스 예외
├── ErrorResponse.java          # 오류 응답 포맷
└── GlobalExceptionHandler.java # 전역 예외 처리
```

**왜 이렇게 설계했는가?**

1. **CustomException**
   - 비즈니스 로직별 예외 정의
   - 에러 코드와 메시지 분리

2. **GlobalExceptionHandler**
   - 모든 예외를 한 곳에서 처리
   - 일관된 오류 응답 형식

3. **MessageSource 활용**
   - 다국어 지원
   - 에러 메시지 외부화

### 5.3 로깅 시스템

```java
com.cmm.interceptor/
├── RequestLoggingAspect.java   # 요청/응답 로깅
├── AopExceptionTransfer.java   # 예외 로깅
├── jpa/
│   └── P6SpyFormatter.java    # SQL 로깅
└── mybatis/
    └── QueryLoggingPlugin.java # MyBatis 쿼리 로깅
```

**왜 여러 로깅 시스템을 만들었는가?**

1. **RequestLoggingAspect**
   - 컨트롤러 요청/응답 로깅
   - AOP 기반으로 자동 로깅

2. **P6SpyFormatter**
   - JPA 쿼리 로깅
   - 실행 시간, 스택 트레이스 포함

3. **QueryLoggingPlugin**
   - MyBatis 쿼리 로깅
   - 파라미터 바인딩 정보 포함

### 5.4 DAO 추상화

```java
com.cmm.dao/
└── AbstractDAO.java
```

**왜 AbstractDAO를 만들었는가?**

1. **공통 CRUD 메서드 제공**
   - selectOne, selectList, insert, update, delete
   - 반복 코드 제거

2. **Optional 활용**
   - Null-safe 처리
   - 함수형 프로그래밍 스타일

---

## 6. 비즈니스 로직 개발

### 6.1 도메인 설계

```java
dev/
├── auth/           # 인증 도메인
│   ├── controller/
│   ├── dto/
│   ├── service/
│   └── jpa/
│       ├── entity/
│       └── repository/
└── menu/           # 메뉴 도메인
    ├── controller/
    └── service/
```

### 6.2 계층별 역할

1. **Controller Layer**
   - HTTP 요청/응답 처리
   - 입력 검증
   - 예외 처리

2. **Service Layer**
   - 비즈니스 로직 처리
   - 트랜잭션 관리
   - 도메인 간 협력

3. **Repository Layer**
   - 데이터 접근 추상화
   - JPA Repository 활용

4. **Entity Layer**
   - 도메인 객체 정의
   - JPA 매핑

### 6.3 DTO 설계

```java
// RegisterDto.java - 회원가입 요청
// UserDto.java - 사용자 정보 응답
```

**왜 DTO를 분리했는가?**

1. **입력과 출력 분리**
   - RegisterDto: 입력 검증
   - UserDto: 응답 데이터

2. **보안 고려**
   - 비밀번호 등 민감 정보 제외
   - 필요한 정보만 노출

---

## 7. 배포 및 운영

### 7.1 프로파일 설정

```properties
# application.properties
spring.profiles.active=dev

# application-dev.properties
# 개발 환경 설정

# application-prod.properties  
# 운영 환경 설정
```

### 7.2 암호화 설정

```java
// JasyptConfig.java
// 설정 파일의 민감 정보 암호화
```

### 7.3 로깅 설정

```properties
# 개발 환경: 상세 로깅
# 운영 환경: 에러 로깅만
```

---

## 8. 개발 팁

### 8.1 패키지 설계 원칙

1. **단일 책임 원칙**
   - 각 패키지는 하나의 책임만
   - com.cmm: 공통 기능
   - com.config: 설정
   - dev: 비즈니스 로직

2. **의존성 방향**
   - dev → com (비즈니스 → 공통)
   - com → config (공통 → 설정)

3. **확장성 고려**
   - 새로운 도메인 추가 용이
   - 공통 모듈 재사용

### 8.2 보안 고려사항

1. **XSS 방지**
   - 모든 입력값 검증
   - 출력값 이스케이프

2. **SQL Injection 방지**
   - PreparedStatement 사용
   - MyBatis 파라미터 바인딩

3. **JWT 보안**
   - 토큰 만료 시간 설정
   - 서명 검증

### 8.3 성능 최적화

1. **데이터베이스**
   - 인덱스 설계
   - 쿼리 최적화

2. **캐싱**
   - JPA 2차 캐시
   - MyBatis 캐시

3. **로깅**
   - 개발 환경: 상세 로깅
   - 운영 환경: 최소 로깅

---

## 9. 다음 단계

### 9.1 추가 기능 구현

1. **파일 업로드**
2. **이메일 발송**
3. **스케줄링**
4. **캐싱**

### 9.2 모니터링

1. **Actuator 추가**
2. **메트릭 수집**
3. **알림 설정**

### 9.3 테스트

1. **단위 테스트**
2. **통합 테스트**
3. **API 테스트**

---

## 10. 참고 자료

- [Spring Boot 공식 문서](https://spring.io/projects/spring-boot)
- [Spring Security 가이드](https://spring.io/projects/spring-security)
- [JPA 가이드](https://spring.io/projects/spring-data-jpa)
- [MyBatis 가이드](https://mybatis.org/mybatis-3/)
- [JWT 가이드](https://jwt.io/)

---

이 가이드를 따라하면 안전하고 확장 가능한 Spring Boot 애플리케이션을 구축할 수 있습니다.
각 단계별로 이해하고 적용하시기 바랍니다. 